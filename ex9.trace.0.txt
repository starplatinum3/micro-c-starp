⭐⭐⭐ 考试内容，务必理解


int t;

void main(int i) {
  int r;
  fac(i, &r);
  print r;
}

res =&r
val res =val addr r
val res=r
*res=r
void fac(int n, int *res) {
  // print &n;			// Show n's address
  if (n == 0)
    *res = 1;
  else {
    int tmp;
    fac(n - 1, &tmp);
    *res = tmp * n;
  }
}


栈帧下标从0开始
 |
 v
[ ]{0: INCSP 1}               // int t;  没有使用的全局变量  一个int 开一个吗
[ 0 ]{2: LDARGS}              // main 命令行参数 i = 0  ,   load args
[ 0 0 ]{3: CALL 1 7}          // 调用 位于7 的 main(0) 函数 参数个数为1  ，这是个数 而不是参数本身吗
                              // 栈帧内容 [6 -999 0] 的解释
                              // CALL 1 7 拿掉栈上1个参数 0 
                              // 放上 返回地址: 6  ,为什么是6 不是4
                                      old bp: -999   默认初始bp值为 -999
                                       参数i : 0
           i                            
[ 0 6 -999 0 ]{7: INCSP 1}    // 给 int  r; 留空间 。 7 开始是这个函数？

             r
[ 0 6 -999 0 0 ]{9: GETBP}    // bp = 3，为啥是3 这个是参数 传入的参数决定吗 ,是因为之前有三个吗  ,3 的位置
[ 0 6 -999 0 0 3 ]{10: CSTI 0}   bp + 0   main参数 i的位置
[ 0 6 -999 0 0 3 0 ]{12: ADD}
               &i
[ 0 6 -999 0 0 3 ]{13: LDI}   //  得到参数 i=0
               i 去取得i 的值了，下标3 的值是0 
[ 0 6 -999 0 0 0 ]{14: GETBP}
[ 0 6 -999 0 0 0 3 ]{15: CSTI 1}  bp+1  main局部变量r的位置  ，栈顶往下移动1  就是他吗 int 是一个位置？
[ 0 6 -999 0 0 0 3 1 ]{17: ADD}   bp+1   &r=4       ，add 说的是指针 +1 吗，但是 cst 1是什么 ，r这个变量的地址        

               i &r
[ 0 6 -999 0 0 0 4 ]{18: CALL 2 35}   //调用 位于 35 的fac(0,4)  4是r的在栈上的地址 &r
                                      // CALL 2 35 拿掉栈上的两个参数 0 4
                                      // 返回地址 = 21，oldbp = 3
              ra oldbp
                | |
                v v n &r                      
[ 0 6 -999 0 0 21 3 0 4 ]{35: GETBP}  // fac(0,4)函数开始执行, 0 4 为参数, bp 指向第1个参数i=0的位置

                    bp
                    |
                    v  
                    n &r = res
                    | |
                    v v
[ 0 6 -999 0 0 21 3 0 4 7 ]{36: CSTI 0}
[ 0 6 -999 0 0 21 3 0 4 7 0 ]{38: ADD}
[ 0 6 -999 0 0 21 3 0 4 7 ]{39: LDI}   // 得到 fac 参数n的值 =0
[ 0 6 -999 0 0 21 3 0 4 0 ]{40: CSTI 0}   
[ 0 6 -999 0 0 21 3 0 4 0 0 ]{42: EQ}     //  n = 0 ?
[ 0 6 -999 0 0 21 3 0 4 1 ]{43: IFZERO 57}  // n != 0  else 转到 57 条件为FALSE 则跳转  ，如果 n==0 是错的就跳转，zero就是走else
[ 0 6 -999 0 0 21 3 0 4 ]{45: GETBP}         // n=0 执行
[ 0 6 -999 0 0 21 3 0 4 7 ]{46: CSTI 1}
[ 0 6 -999 0 0 21 3 0 4 7 1 ]{48: ADD}  
                                        //这里没有跳转吗 ,没有跳转是因为 条件成立了
                    res &res           //res是指针指针本身的地址 &res 是 8
                      | |              //指针res的值 是r的地址，&r = 4 =res
                      v v              //指针res的内容 *res是r的值，r = 0  这是一个栈上的三个数字吗 对应的 *res res &res 
[ 0 6 -999 0 0 21 3 0 4 8 ]{49: LDI}   // *res的左值 = 4
                        
[ 0 6 -999 0 0 21 3 0 4 4 ]{50: CSTI 1}
         

           *res     n &r = res
             |      | |
             v      v v
[ 0 6 -999 0 0 21 3 0 4 4 1 ]{52: STI}  // *res = 1  注意: STI对栈上位置4 赋值 1
                                        // 赋值完成后，该值保留在栈上
                                        // 为啥是4 ,难道是因为&r = 4 , r 的地址是4 吗，*res *res=r
                                        应该是栈顶的第二个是4  他作为下标
           *res
             |
             v
[ 0 6 -999 0 1 21 3 0 4 1 ]{53: INCSP -1} // 忽略栈上的*res的值
            ^^^

[ 0 6 -999 0 1 21 3 0 4 ]{55: GOTO 97}
[ 0 6 -999 0 1 21 3 0 4 ]{97: INCSP 0}  //fac 没有局部变量
[ 0 6 -999 0 1 21 3 0 4 ]{99: RET 1}    //从 fac(0,4)返回 撤销栈帧  return; RET m-1                                         //                    fac参数个数 m=2
 之前有两个参数 两个的话 需要回退两个
int res = s[sp]; 
        // 栈顶   res =4  栈顶的值
        sp = sp-p[pc]; ,指令1  回退1 ? [ 0 6 -999 0 1 21 3 0(sp) 4 ]
        // 栈顶变成了 原来的栈顶- 现在的指令 
        bp = s[--sp];
        // 栈底回退一格   [ 0 6 -999 0 1 21 3(bp) 0(sp) 4 ]
         pc = s[--sp]; 
        //  指令回退 [ 0 6 -999 0 1 21(pc) 3(bp) 0(sp) 4 ]
        s[sp] = res;   
        // 栈顶放上返回值  21 的位子变成 4
[ 0 6 -999 0 1 4 ]{21: INCSP -1}       //  fac(0); 丢弃 fac(0);的值 

[ 0 6 -999 0 1 ]{23: GETBP}             
[ 0 6 -999 0 1 3 ]{24: CSTI 1}
[ 0 6 -999 0 1 3 1 ]{26: ADD}          //得到r的偏移地址  
[ 0 6 -999 0 1 4 ]{27: LDI}           // 得到main 的值 r
[ 0 6 -999 0 1 1 ]{28: PRINTI}       //输出 r
1 [ 0 6 -999 0 1 1 ]{29: INCSP -1}   // 丢弃 PRINTI 的值 (r值) , printi 出来是一个expr 所以有值吗 所以要丢掉？
[ 0 6 -999 0 1 ]{31: INCSP -1}  // 丢弃 main 的局部变量 r
[ 0 6 -999 0 ]{33: RET 0}          //  从main(0) 中 return; RET m-1
                                   // main 参数个数 m=1 
[ 0 0 ]{6: STOP}             // 执行结束                  
